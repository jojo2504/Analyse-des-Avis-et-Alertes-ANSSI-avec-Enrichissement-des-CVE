
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical, ScrollableContainer
from textual.widgets import Header, Footer, Button, Static, DataTable, Input, RichLog, TabbedContent, TabPane, Label
from textual.binding import Binding
from textual.screen import Screen
import feedparser
import requests
import re
from datetime import datetime
from typing import List, Dict, Any
from time import strftime

# Neww
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Pour sauvegarder les graphiques sans les afficher
import matplotlib.pyplot as plt


class CVEDetailScreen(Screen):
    """Screen to display detailed CVE information"""
    
    BINDINGS = [
        Binding("escape", "back", "Back"),
    ]
    
    def __init__(self, cve_id: str):
        super().__init__()
        self.cve_id = cve_id
        self.cve_data = None
        self.epss_data = None
    
    def compose(self) -> ComposeResult:
        yield Header()
        with ScrollableContainer(id="cve-scroll"):
            yield Static(f"Loading CVE details for {self.cve_id}...", id="cve-details")
        yield Footer()
    
    def on_mount(self) -> None:
        self.fetch_cve_details()
    
    def fetch_cve_details(self) -> None:
        try:
            url = f"https://cveawg.mitre.org/api/cve/{self.cve_id}"
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            self.cve_data = response.json()
            
            epss_url = f"https://api.first.org/data/v1/epss?cve={self.cve_id}"
            epss_response = requests.get(epss_url, timeout=10)
            self.epss_data = epss_response.json()
            
            self.display_cve_details()
        except Exception as e:
            self.query_one("#cve-details", Static).update(f"[red]Error fetching CVE details: {str(e)}[/red]")
    
    def display_cve_details(self) -> None:
        if not self.cve_data:
            return
        
        try:
            description = self.cve_data["containers"]["cna"]["descriptions"][0]["value"]
            
            cvss_score = "N/A"
            cvss_severity = "N/A"
            metrics = self.cve_data["containers"]["cna"].get("metrics", [])
            if metrics:
                for metric in metrics:
                    if "cvssV3_1" in metric:
                        cvss_score = metric["cvssV3_1"]["baseScore"]
                        cvss_severity = metric["cvssV3_1"].get("baseSeverity", "N/A")
                        break
                    elif "cvssV3_0" in metric:
                        cvss_score = metric["cvssV3_0"]["baseScore"]
                        cvss_severity = metric["cvssV3_0"].get("baseSeverity", "N/A")
                        break
            
            cwe = "Non disponible"
            cwe_desc = "Non disponible"
            problemtype = self.cve_data["containers"]["cna"].get("problemTypes", [])
            if problemtype and "descriptions" in problemtype[0]:
                cwe = problemtype[0]["descriptions"][0].get("cweId", "Non disponible")
                cwe_desc = problemtype[0]["descriptions"][0].get("description", "Non disponible")
            
            epss_score = "N/A"
            epss_percentile = "N/A"
            if self.epss_data and self.epss_data.get("data"):
                epss_score = self.epss_data["data"][0]["epss"]
                epss_percentile = self.epss_data["data"][0].get("percentile", "N/A")
            
            affected_products = []
            affected = self.cve_data["containers"]["cna"].get("affected", [])
            for product in affected:
                vendor = product.get("vendor", "Unknown")
                product_name = product.get("product", "Unknown")
                versions = [v["version"] for v in product.get("versions", []) if v.get("status") == "affected"]
                affected_products.append(f"  â€¢ {vendor} - {product_name}: {', '.join(versions) if versions else 'All versions'}")
            
            severity_color = "white"
            if cvss_score != "N/A":
                score = float(cvss_score)
                if score >= 9.0:
                    severity_color = "red bold"
                elif score >= 7.0:
                    severity_color = "yellow bold"
                elif score >= 4.0:
                    severity_color = "cyan"
                else:
                    severity_color = "green"
            
            details_text = f"""[bold cyan]{self.cve_id}[/bold cyan]

[bold]Description:[/bold]
{description}

[bold]Scores:[/bold]
  â€¢ CVSS Score: [{severity_color}]{cvss_score}[/{severity_color}] ({cvss_severity})
  â€¢ EPSS Score: {epss_score} (Percentile: {epss_percentile})

[bold]CWE Information:[/bold]
  â€¢ Type: {cwe}
  â€¢ Description: {cwe_desc}

[bold]Affected Products:[/bold]
{''.join([f'{chr(10)}{p}' for p in affected_products]) if affected_products else chr(10) + '  No products listed'}

[dim]Press ESC to go back[/dim]
"""
            
            self.query_one("#cve-details", Static).update(details_text)
        except Exception as e:
            self.query_one("#cve-details", Static).update(f"[red]Error parsing CVE data: {str(e)}[/red]")
    
    def action_back(self) -> None:
        self.app.pop_screen()


# ============================================================================
# Ã‰CRAN DE DÃ‰TAIL BULLETIN (code de ton pote - inchangÃ©)
# ============================================================================
class EntryDetailScreen(Screen):
    """Screen to display entry details with extracted CVEs"""
    
    BINDINGS = [
        Binding("escape", "back", "Back"),
    ]
    
    def __init__(self, entry_title: str, entry_link: str):
        super().__init__()
        self.entry_title = entry_title
        self.entry_link = entry_link
        self.cve_list = []
    
    def compose(self) -> ComposeResult:
        yield Header()
        with Vertical():
            yield Static(f"[bold cyan]{self.entry_title}[/bold cyan]", id="entry-title")
            yield Static(f"[dim]{self.entry_link}[/dim]", id="entry-link")
            yield Static("Loading CVEs...", id="cve-status")
            yield DataTable(id="cve-table")
        yield Footer()
    
    def on_mount(self) -> None:
        table = self.query_one("#cve-table", DataTable)
        table.add_columns("CVE ID", "CVSS", "EPSS", "Description")
        table.cursor_type = "row"
        self.fetch_cves()
    
    def fetch_cves(self) -> None:
        try:
            json_url = self.entry_link.rstrip("/") + "/json/"
            response = requests.get(json_url, timeout=10)
            data = response.json()
            
            ref_cves = data.get("cves", [])
            cve_pattern = r"CVE-\d{4}-\d{4,7}"
            cve_list = list(set(re.findall(cve_pattern, str(data))))
            
            all_cves = set()
            for cve in ref_cves:
                all_cves.add(cve.get("name", ""))
            all_cves.update(cve_list)
            all_cves.discard("")
            
            self.cve_list = sorted(list(all_cves))
            
            status_text = f"Found {len(self.cve_list)} CVE(s)"
            if len(self.cve_list) > 0:
                status_text += " - Click on a row to see details"
            self.query_one("#cve-status", Static).update(status_text)
            
            if self.cve_list:
                self.load_cve_summaries()
            else:
                self.query_one("#cve-status", Static).update("[yellow]No CVEs found in this entry[/yellow]")
            
        except Exception as e:
            self.query_one("#cve-status", Static).update(f"[red]Error fetching CVEs: {str(e)}[/red]")
    
    def load_cve_summaries(self) -> None:
        table = self.query_one("#cve-table", DataTable)
        
        for cve_id in self.cve_list:
            try:
                url = f"https://cveawg.mitre.org/api/cve/{cve_id}"
                response = requests.get(url, timeout=5)
                data = response.json()
                
                cvss_score = "N/A"
                metrics = data["containers"]["cna"].get("metrics", [])
                if metrics:
                    for metric in metrics:
                        if "cvssV3_1" in metric:
                            cvss_score = str(metric["cvssV3_1"]["baseScore"])
                            break
                        elif "cvssV3_0" in metric:
                            cvss_score = str(metric["cvssV3_0"]["baseScore"])
                            break
                
                epss_score = "N/A"
                epss_url = f"https://api.first.org/data/v1/epss?cve={cve_id}"
                epss_response = requests.get(epss_url, timeout=5)
                epss_data = epss_response.json()
                if epss_data.get("data"):
                    epss_score = epss_data["data"][0]["epss"]
                
                description = data["containers"]["cna"]["descriptions"][0]["value"]
                desc_short = description[:60] + "..." if len(description) > 60 else description
                
                table.add_row(cve_id, cvss_score, epss_score, desc_short)
                
            except Exception as e:
                table.add_row(cve_id, "Error", "Error", f"Failed to load: {str(e)[:30]}")
    
    def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
        table = self.query_one("#cve-table", DataTable)
        row = table.get_row(event.row_key)
        cve_id = row[0]
        
        if cve_id and not cve_id.startswith("Error"):
            self.app.push_screen(CVEDetailScreen(cve_id))
    
    def action_back(self) -> None:
        self.app.pop_screen()

class ANSSIMonitorApp(App):
    """A Textual app to monitor ANSSI security advisories and alerts."""
    
    CSS = """
    #feed-container {
        height: 100%;
        border: solid green;
    }
    
    #cve-container, #cve-scroll {
        height: 100%;
        border: solid cyan;
        padding: 1 2;
    }
    
    DataTable {
        height: 1fr;
    }
    
    #status-log {
        height: 10;
        border: solid yellow;
        margin-top: 1;
    }
    
    .button-row {
        height: auto;
        margin: 1 0;
    }
    
    Button {
        margin: 0 1;
    }
    
    #entry-title {
        margin: 1;
    }
    
    #entry-link {
        margin: 0 1 1 1;
    }
    
    #cve-status {
        margin: 1;
        background: $boost;
        padding: 1;
    }
    
    #stats-display {
        padding: 1 2;
        background: $surface;
    }
    
    #alert-status {
        padding: 1;
        margin: 1;
    }
    """
    
    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("r", "refresh", "Refresh"),
        Binding("c", "clear_log", "Clear Log"),
    ]
    
    FEED_URLS = {
        "avis": "https://www.cert.ssi.gouv.fr/avis/feed/",
        "alertes": "https://www.cert.ssi.gouv.fr/alerte/feed/",
        "complet": "https://www.cert.ssi.gouv.fr/feed/",
        "actualite": "https://www.cert.ssi.gouv.fr/actualite/feed/",
        "scada": "https://www.cert.ssi.gouv.fr/feed/scada/",
        "cti": "https://www.cert.ssi.gouv.fr/cti/feed/",
        "ioc": "https://www.cert.ssi.gouv.fr/ioc/feed/",
        "dur": "https://www.cert.ssi.gouv.fr/dur/feed/"
    }
    
    def __init__(self):
        super().__init__()
        self.current_feed_type = "complet"
        self.feed_data = []
        
        self.df_donnees = None  
        self.alertes_df = None  
    
    def compose(self) -> ComposeResult:
        yield Header()
        
        with TabbedContent():
            
            with TabPane("ðŸ“° Feed Viewer", id="tab-feed"):
                with Vertical(id="feed-container"):
                    with Horizontal(classes="button-row"):
                        yield Button("Avis", id="btn-avis", variant="primary")
                        yield Button("Alertes", id="btn-alertes", variant="primary")
                        yield Button("Complet", id="btn-complet", variant="success")
                        yield Button("ActualitÃ©", id="btn-actualite", variant="primary")
                    with Horizontal(classes="button-row"):
                        yield Button("SCADA", id="btn-scada", variant="warning")
                        yield Button("CTI", id="btn-cti", variant="warning")
                        yield Button("IOC", id="btn-ioc", variant="warning")
                        yield Button("DUR", id="btn-dur", variant="warning")
                        yield Button("Refresh", id="btn-refresh", variant="default")
                    
                    yield DataTable(id="feed-table")
                    yield RichLog(id="status-log", highlight=True)
            
            
            with TabPane("ðŸ” CVE Search", id="tab-cve"):
                with Vertical():
                    with Horizontal(classes="button-row"):
                        yield Label("CVE ID:")
                        yield Input(placeholder="CVE-YYYY-NNNN", id="cve-input")
                        yield Button("Search", id="btn-search-cve", variant="primary")
                    yield ScrollableContainer(
                        Static("Enter a CVE ID to search (e.g., CVE-2023-46805)", id="cve-search-results"),
                    )
            
            
            with TabPane("ðŸ“Š Analyse", id="tab-analyse"):
                with Vertical():
                    with Horizontal(classes="button-row"):
                        yield Button("1. Collecter DonnÃ©es", id="btn-collecter", variant="primary")
                        yield Button("2. Voir Stats", id="btn-stats", variant="success")
                        yield Button("3. Exporter CSV", id="btn-export", variant="warning")
                        yield Button("4. Graphiques", id="btn-graphiques", variant="error")
                    yield Static("[dim]Cliquez sur 'Collecter DonnÃ©es' pour commencer[/dim]", id="stats-display")
            
            
            with TabPane("ðŸš¨ Alertes", id="tab-alertes"):
                with Vertical():
                    with Horizontal(classes="button-row"):
                        yield Label("Seuil CVSS:")
                        yield Input(placeholder="9.0", value="9.0", id="seuil-input")
                        yield Button("VÃ©rifier Alertes", id="btn-alertes-check", variant="error")
                        yield Button("Sauver Rapport", id="btn-sauver-alertes", variant="warning")
                    yield Static("[dim]Collectez d'abord les donnÃ©es dans l'onglet Analyse[/dim]", id="alert-status")
                    yield DataTable(id="alert-table")
        
        yield Footer()
    
    def on_mount(self) -> None:
        """Initialize the data table and load initial feed."""
        table = self.query_one("#feed-table", DataTable)
        table.add_columns("Date", "Type", "Title")
        table.cursor_type = "row"
        
        alert_table = self.query_one("#alert-table", DataTable)
        alert_table.add_columns("CVE", "CVSS", "SÃ©vÃ©ritÃ©", "Vecteur", "Bulletin")
        
        self.log_message("[cyan]Welcome to ANSSI Monitor![/cyan]")
        self.log_message(f"[dim]Available feeds: {', '.join(self.FEED_URLS.keys())}[/dim]")
        self.load_feed("complet")
    
    def log_message(self, message: str) -> None:
        """Log a message to the status log."""
        status_log = self.query_one("#status-log", RichLog)
        timestamp = datetime.now().strftime("%H:%M:%S")
        status_log.write(f"[{timestamp}] {message}")
    
    def action_clear_log(self) -> None:
        status_log = self.query_one("#status-log", RichLog)
        status_log.clear()
        self.log_message("[dim]Log cleared[/dim]")
    
    def action_refresh(self) -> None:
        self.load_feed(self.current_feed_type)
    
    def load_feed(self, feed_type: str) -> None:
        """Load RSS feed based on type"""
        self.current_feed_type = feed_type
        
        url = self.FEED_URLS.get(feed_type)
        if not url:
            self.log_message(f"[red]Unknown feed type: {feed_type}[/red]")
            return
        
        self.log_message(f"Loading feed: [cyan]{feed_type}[/cyan] from {url}")
        
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            feed = feedparser.parse(response.content)
            
            if feed.bozo and feed.bozo_exception:
                self.log_message(f"[yellow]Feed parsing warning: {feed.bozo_exception}[/yellow]")
            
            if not feed.entries:
                self.log_message(f"[yellow]No entries found in feed[/yellow]")
                table = self.query_one("#feed-table", DataTable)
                table.clear()
                return
            
            self.feed_data = feed.entries
            
            table = self.query_one("#feed-table", DataTable)
            table.clear()
            
            entries_added = 0
            for entry in feed.entries:
                date = "N/A"
                if hasattr(entry, 'published'):
                    date = entry.published[:10] if len(entry.published) >= 10 else entry.published
                elif hasattr(entry, 'updated'):
                    date = entry.updated[:10] if len(entry.updated) >= 10 else entry.updated
                elif hasattr(entry, 'published_parsed') and entry.published_parsed:
                    date = strftime("%Y-%m-%d", entry.published_parsed)
                
                entry_type = "OTHER"
                link = ""
                
                if hasattr(entry, 'link'):
                    link = entry.link
                    link_lower = link.lower()
                    if "avis" in link_lower:
                        entry_type = "AVIS"
                    elif "alerte" in link_lower:
                        entry_type = "ALERTE"
                    elif "actualite" in link_lower:
                        entry_type = "ACTU"
                    elif "scada" in link_lower:
                        entry_type = "SCADA"
                    elif "cti" in link_lower:
                        entry_type = "CTI"
                    elif "ioc" in link_lower:
                        entry_type = "IOC"
                    elif "dur" in link_lower:
                        entry_type = "DUR"
                
                title = "No title"
                if hasattr(entry, 'title'):
                    title = entry.title
                elif hasattr(entry, 'summary'):
                    title = entry.summary[:100] + "..." if len(entry.summary) > 100 else entry.summary
                
                if title != "No title" or link:
                    table.add_row(date, entry_type, title, key=link if link else f"row_{entries_added}")
                    entries_added += 1
            
            if entries_added > 0:
                self.log_message(f"[green]âœ“ Successfully loaded {entries_added} entries[/green]")
            else:
                self.log_message(f"[yellow]Parsed feed but found no valid entries[/yellow]")
            
        except requests.exceptions.Timeout:
            self.log_message(f"[red]âœ— Timeout error[/red]")
        except requests.exceptions.ConnectionError:
            self.log_message(f"[red]âœ— Connection error[/red]")
        except requests.exceptions.HTTPError as e:
            self.log_message(f"[red]âœ— HTTP error: {e}[/red]")
        except Exception as e:
            self.log_message(f"[red]âœ— Error loading feed: {str(e)}[/red]")
    
    # NEWWwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
    def collecter_donnees(self) -> None:
        """
        OBJECTIF 4: Collecter les donnÃ©es et crÃ©er un DataFrame pandas
        """
        stats_display = self.query_one("#stats-display", Static)
        stats_display.update("[yellow]â³ Collecte des donnÃ©es en cours... Patientez![/yellow]")
        
        self.log_message("[cyan]DÃ©but de la collecte des donnÃ©es...[/cyan]")
        
        if not self.feed_data:
            stats_display.update("[red] Aucune donnÃ©e. Chargez d'abord un feed![/red]")
            return
        
        
        donnees = []
        
        
        bulletins_a_traiter = self.feed_data[:5]
        
        for i, entry in enumerate(bulletins_a_traiter):
            self.log_message(f"[dim]Traitement {i+1}/{len(bulletins_a_traiter)}...[/dim]")
            
            
            titre = getattr(entry, 'title', 'Sans titre')
            lien = getattr(entry, 'link', '')
            date = getattr(entry, 'published', 'N/A')
            
            
            type_bulletin = "AUTRE"
            if "avis" in lien.lower():
                type_bulletin = "AVIS"
            elif "alerte" in lien.lower():
                type_bulletin = "ALERTE"
            
            
            try:
                json_url = lien.rstrip("/") + "/json/"
                response = requests.get(json_url, timeout=10)
                data = response.json()
                
                
                cves = list(set(re.findall(r"CVE-\d{4}-\d{4,7}", str(data))))
                
                
                for cve_id in cves[:3]:  
                    try:
                      
                        url_cve = f"https://cveawg.mitre.org/api/cve/{cve_id}"
                        resp_cve = requests.get(url_cve, timeout=5)
                        cve_data = resp_cve.json()
                        
                        cna = cve_data.get("containers", {}).get("cna", {})
                        
                        
                        cvss_score = None
                        cvss_severity = None
                        vecteur = None
                        
                        for metric in cna.get("metrics", []):
                            if "cvssV3_1" in metric:
                                cvss_score = metric["cvssV3_1"].get("baseScore")
                                cvss_severity = metric["cvssV3_1"].get("baseSeverity")
                                vecteur = metric["cvssV3_1"].get("attackVector")
                                break
                            elif "cvssV3_0" in metric:
                                cvss_score = metric["cvssV3_0"].get("baseScore")
                                cvss_severity = metric["cvssV3_0"].get("baseSeverity")
                                vecteur = metric["cvssV3_0"].get("attackVector")
                                break
                        
                        
                        descriptions = cna.get("descriptions", [])
                        description = descriptions[0].get("value", "")[:100] if descriptions else ""
                        
                        
                        donnees.append({
                            'bulletin_titre': titre,
                            'bulletin_type': type_bulletin,
                            'bulletin_date': date,
                            'bulletin_lien': lien,
                            'cve_id': cve_id,
                            'cvss_score': cvss_score,
                            'cvss_severity': cvss_severity,
                            'vecteur_attaque': vecteur,
                            'description': description
                        })
                        
                    except:
                        # Si erreur sur une CVE, on continue goooo
                        donnees.append({
                            'bulletin_titre': titre,
                            'bulletin_type': type_bulletin,
                            'bulletin_date': date,
                            'bulletin_lien': lien,
                            'cve_id': cve_id,
                            'cvss_score': None,
                            'cvss_severity': None,
                            'vecteur_attaque': None,
                            'description': "Erreur de rÃ©cupÃ©ration"
                        })
            except:
                self.log_message(f"[yellow]âš  Erreur sur {titre[:30]}...[/yellow]")
                continue
        
    
        self.df_donnees = pd.DataFrame(donnees)
    
        nb_lignes = len(self.df_donnees)
        nb_cves = self.df_donnees['cve_id'].nunique() if nb_lignes > 0 else 0
        
        stats_display.update(f"""[green]âœ… DonnÃ©es collectÃ©es avec succÃ¨s![/green]

ðŸ“Š [bold]RÃ©sumÃ©:[/bold]
   â€¢ Lignes dans le DataFrame: {nb_lignes}
   â€¢ CVE uniques: {nb_cves}
   â€¢ Bulletins traitÃ©s: {len(bulletins_a_traiter)}

[dim]Cliquez sur 'Voir Stats' pour plus de dÃ©tails[/dim]
""")
        
        self.log_message(f"[green]âœ“ DataFrame crÃ©Ã©: {nb_lignes} lignes[/green]")
    
    def afficher_stats(self) -> None:
        """
        OBJECTIF 5: Afficher les statistiques
        """
        stats_display = self.query_one("#stats-display", Static)
        
        if self.df_donnees is None or len(self.df_donnees) == 0:
            stats_display.update("[red]âŒ Pas de donnÃ©es. Cliquez d'abord sur 'Collecter DonnÃ©es'[/red]")
            return
        
        df = self.df_donnees
        
        # Calcul des statos
        nb_total = len(df)
        nb_cves = df['cve_id'].nunique()
        nb_bulletins = df['bulletin_titre'].nunique()
        
        # Stats CVSS (par secutire sans les None)
        scores = df['cvss_score'].dropna()
        if len(scores) > 0:
            cvss_moyen = scores.mean()
            cvss_max = scores.max()
            cvss_min = scores.min()
            nb_critiques = len(scores[scores >= 9.0])
            nb_eleves = len(scores[(scores >= 7.0) & (scores < 9.0)])
        else:
            cvss_moyen = cvss_max = cvss_min = 0
            nb_critiques = nb_eleves = 0
        
        # Distribution des sÃ©vÃ©ritÃ©s
        severites = df['cvss_severity'].value_counts().to_dict()
        
        # Vecteurs d'attaque
        vecteurs = df['vecteur_attaque'].value_counts().to_dict()
        
        # Types de bulletins
        types = df['bulletin_type'].value_counts().to_dict()
        
        # Construire l'affichage
        texte = f"""[bold green]ðŸ“ˆ STATISTIQUES DU DATAFRAME[/bold green]

[bold cyan]â•â•â• RÃ©sumÃ© GÃ©nÃ©ral â•â•â•[/bold cyan]
  â€¢ Total de lignes: {nb_total}
  â€¢ CVE uniques: {nb_cves}
  â€¢ Bulletins: {nb_bulletins}

[bold cyan]â•â•â• Scores CVSS â•â•â•[/bold cyan]
  â€¢ Score moyen: {cvss_moyen:.2f}
  â€¢ Score maximum: {cvss_max}
  â€¢ Score minimum: {cvss_min}
  â€¢ CVE critiques (â‰¥9.0): [red]{nb_critiques}[/red]
  â€¢ CVE Ã©levÃ©es (â‰¥7.0): [yellow]{nb_eleves}[/yellow]

[bold cyan]â•â•â• Distribution SÃ©vÃ©ritÃ© â•â•â•[/bold cyan]"""
        
        for sev, count in severites.items():
            if sev:
                couleur = "red" if sev == "CRITICAL" else "yellow" if sev == "HIGH" else "white"
                texte += f"\n  â€¢ {sev}: [{couleur}]{count}[/{couleur}]"
        
        texte += "\n\n[bold cyan]â•â•â• Vecteurs d'Attaque â•â•â•[/bold cyan]"
        for vec, count in vecteurs.items():
            if vec:
                texte += f"\n  â€¢ {vec}: {count}"
        
        texte += "\n\n[bold cyan]â•â•â• Types de Bulletins â•â•â•[/bold cyan]"
        for typ, count in types.items():
            couleur = "red" if typ == "ALERTE" else "cyan"
            texte += f"\n  â€¢ {typ}: [{couleur}]{count}[/{couleur}]"
        
        stats_display.update(texte)
        self.log_message("[green]âœ“ Statistiques affichÃ©es[/green]")
    
    def exporter_csv(self) -> None:
        """
        OBJECTIF 4: Exporter les donnÃ©es en CSV
        """
        stats_display = self.query_one("#stats-display", Static)
        
        if self.df_donnees is None or len(self.df_donnees) == 0:
            stats_display.update("[red]âŒ Pas de donnÃ©es Ã  exporter[/red]")
            return
        
        # Nom du fichier avec date
        nom_fichier = f"anssi_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        # Exporter
        self.df_donnees.to_csv(nom_fichier, index=False, encoding='utf-8')
        
        stats_display.update(f"""[green]âœ… Export rÃ©ussi![/green]

ðŸ“ Fichier crÃ©Ã©: [bold]{nom_fichier}[/bold]

[dim]Le fichier contient {len(self.df_donnees)} lignes[/dim]
""")
        
        self.log_message(f"[green]âœ“ ExportÃ© vers {nom_fichier}[/green]")
    
    def generer_graphiques(self) -> None:
        """
        OBJECTIF 5: GÃ©nÃ©rer des graphiques
        """
        stats_display = self.query_one("#stats-display", Static)
        
        if self.df_donnees is None or len(self.df_donnees) == 0:
            stats_display.update("[red]âŒ Pas de donnÃ©es pour les graphiques[/red]")
            return
        
        df = self.df_donnees
        
        fig, axes = plt.subplots(1, 2, figsize=(12, 5))
        
        # Graphique 1: Distribution des sÃ©vÃ©ritÃ©s
        ax1 = axes[0]
        severites = df['cvss_severity'].value_counts()
        couleurs = {'CRITICAL': 'red', 'HIGH': 'orange', 'MEDIUM': 'yellow', 'LOW': 'green'}
        colors = [couleurs.get(s, 'gray') for s in severites.index]
        ax1.bar(severites.index, severites.values, color=colors)
        ax1.set_title('RÃ©partition par SÃ©vÃ©ritÃ©', fontweight='bold')
        ax1.set_xlabel('SÃ©vÃ©ritÃ©')
        ax1.set_ylabel('Nombre de CVE')
        
        # Graphique 2: Histogramme CVSS
        ax2 = axes[1]
        scores = df['cvss_score'].dropna()
        if len(scores) > 0:
            ax2.hist(scores, bins=10, color='steelblue', edgecolor='white')
            ax2.axvline(x=9.0, color='red', linestyle='--', linewidth=2, label='Critique (â‰¥9)')
            ax2.axvline(x=7.0, color='orange', linestyle='--', linewidth=2, label='Ã‰levÃ© (â‰¥7)')
            ax2.set_xlim(0, 10)
            ax2.legend()
        ax2.set_title('Distribution des Scores CVSS', fontweight='bold')
        ax2.set_xlabel('Score CVSS')
        ax2.set_ylabel('Nombre de CVE')
        
        plt.tight_layout()
        
        nom_fichier = f"graphiques_anssi_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        plt.savefig(nom_fichier, dpi=150)
        plt.close()
        
        stats_display.update(f"""[green]âœ… Graphiques gÃ©nÃ©rÃ©s![/green]

ðŸ“Š Fichier crÃ©Ã©: [bold]{nom_fichier}[/bold]

[dim]Ouvrez le fichier pour voir les visualisations[/dim]
""")
        
        self.log_message(f"[green]âœ“ Graphiques sauvegardÃ©s: {nom_fichier}[/green]")
    
    def verifier_alertes(self) -> None:
        """
        OBJECTIF 6: VÃ©rifier les vulnÃ©rabilitÃ©s critiques
        """
        alert_status = self.query_one("#alert-status", Static)
        alert_table = self.query_one("#alert-table", DataTable)
        
        if self.df_donnees is None or len(self.df_donnees) == 0:
            alert_status.update("[red]âŒ Pas de donnÃ©es. Allez dans l'onglet Analyse et collectez d'abord les donnÃ©es![/red]")
            return

        try:
            seuil_input = self.query_one("#seuil-input", Input)
            seuil = float(seuil_input.value)
        except:
            seuil = 9.0
        
        df = self.df_donnees
        
    
        df_alertes = df[df['cvss_score'] >= seuil].copy()
        df_alertes = df_alertes.drop_duplicates(subset=['cve_id'])
        df_alertes = df_alertes.sort_values('cvss_score', ascending=False)
        
        self.alertes_df = df_alertes
        
        alert_table.clear()
        
        for _, row in df_alertes.iterrows():
            cvss = row['cvss_score'] if row['cvss_score'] else "N/A"
            severite = row['cvss_severity'] if row['cvss_severity'] else "N/A"
            vecteur = row['vecteur_attaque'] if row['vecteur_attaque'] else "N/A"
            bulletin = row['bulletin_titre'][:30] + "..." if len(str(row['bulletin_titre'])) > 30 else row['bulletin_titre']
            
            alert_table.add_row(
                row['cve_id'],
                str(cvss),
                str(severite),
                str(vecteur),
                str(bulletin)
            )
        
        
        nb_alertes = len(df_alertes)
        if nb_alertes > 0:
            alert_status.update(f"""[bold red]ðŸš¨ {nb_alertes} VULNÃ‰RABILITÃ‰(S) CRITIQUE(S) DÃ‰TECTÃ‰E(S)![/bold red]

Seuil CVSS: â‰¥ {seuil}

[dim]Ces vulnÃ©rabilitÃ©s nÃ©cessitent une attention immÃ©diate![/dim]
""")
        else:
            alert_status.update(f"""[green]âœ… Aucune vulnÃ©rabilitÃ© critique dÃ©tectÃ©e[/green]

Seuil CVSS: â‰¥ {seuil}

[dim]Toutes les CVE ont un score infÃ©rieur au seuil[/dim]
""")
        
        self.log_message(f"[cyan]Alertes vÃ©rifiÃ©es: {nb_alertes} CVE critiques (seuil {seuil})[/cyan]")
    
    def sauver_alertes(self) -> None:
        """
        OBJECTIF 6: Sauvegarder le rapport d'alertes
        """
        alert_status = self.query_one("#alert-status", Static)
        
        if self.alertes_df is None or len(self.alertes_df) == 0:
            alert_status.update("[yellow]âš  Aucune alerte Ã  sauvegarder. VÃ©rifiez d'abord les alertes![/yellow]")
            return
        
        nom_csv = f"alertes_critiques_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        nom_txt = f"rapport_alertes_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        

        self.alertes_df.to_csv(nom_csv, index=False, encoding='utf-8')
        
        with open(nom_txt, 'w', encoding='utf-8') as f:
            f.write("=" * 60 + "\n")
            f.write("RAPPORT D'ALERTES CRITIQUES - ANSSI\n")
            f.write(f"GÃ©nÃ©rÃ© le: {datetime.now().strftime('%d/%m/%Y Ã  %H:%M')}\n")
            f.write("=" * 60 + "\n\n")
            
            f.write(f"Nombre de vulnÃ©rabilitÃ©s critiques: {len(self.alertes_df)}\n\n")
            
            f.write("-" * 60 + "\n")
            f.write("DÃ‰TAIL DES VULNÃ‰RABILITÃ‰S\n")
            f.write("-" * 60 + "\n\n")
            
            for _, row in self.alertes_df.iterrows():
                f.write(f"CVE: {row['cve_id']}\n")
                f.write(f"  Score CVSS: {row['cvss_score']}\n")
                f.write(f"  SÃ©vÃ©ritÃ©: {row['cvss_severity']}\n")
                f.write(f"  Vecteur: {row['vecteur_attaque']}\n")
                f.write(f"  Bulletin: {row['bulletin_titre']}\n")
                f.write(f"  Lien: {row['bulletin_lien']}\n")
                f.write("\n")
            
            f.write("=" * 60 + "\n")
            f.write("FIN DU RAPPORT\n")
            f.write("=" * 60 + "\n")
        
        alert_status.update(f"""[green]âœ… Rapport sauvegardÃ©![/green]

ðŸ“ Fichiers crÃ©Ã©s:
  â€¢ [bold]{nom_csv}[/bold] (donnÃ©es)
  â€¢ [bold]{nom_txt}[/bold] (rapport lisible)
""")
        
        self.log_message(f"[green]âœ“ Rapport sauvegardÃ©: {nom_csv}, {nom_txt}[/green]")
    
    # GESTION DES BOUTONS YESS
    
    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button clicks."""
        button_id = event.button.id
        

        if button_id == "btn-avis":
            self.load_feed("avis")
        elif button_id == "btn-alertes":
            self.load_feed("alertes")
        elif button_id == "btn-complet":
            self.load_feed("complet")
        elif button_id == "btn-actualite":
            self.load_feed("actualite")
        elif button_id == "btn-scada":
            self.load_feed("scada")
        elif button_id == "btn-cti":
            self.load_feed("cti")
        elif button_id == "btn-ioc":
            self.load_feed("ioc")
        elif button_id == "btn-dur":
            self.load_feed("dur")
        elif button_id == "btn-refresh":
            self.action_refresh()
        elif button_id == "btn-search-cve":
            self.search_cve()
        
        # NEWSS
        elif button_id == "btn-collecter":
            self.collecter_donnees()
        elif button_id == "btn-stats":
            self.afficher_stats()
        elif button_id == "btn-export":
            self.exporter_csv()
        elif button_id == "btn-graphiques":
            self.generer_graphiques()
        elif button_id == "btn-alertes-check":
            self.verifier_alertes()
        elif button_id == "btn-sauver-alertes":
            self.sauver_alertes()
    
    def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
        """Handle row selection in the data table."""
        table = event.data_table
        
        if table.id == "feed-table":
            row_key = event.row_key
            row = table.get_row(row_key)
            
            title = row[2]
            link = str(row_key)
            
            if not link or link == "None" or link.startswith("row_"):
                self.log_message("[yellow]No link available for this entry[/yellow]")
                return
            
            self.log_message(f"[cyan]Selected:[/cyan] {title[:50]}...")
            self.push_screen(EntryDetailScreen(title, link))
    
    def search_cve(self) -> None:
        """Search for a specific CVE."""
        input_widget = self.query_one("#cve-input", Input)
        cve_id = input_widget.value.strip().upper()
        
        if not cve_id:
            self.log_message("[yellow]Please enter a CVE ID[/yellow]")
            return
        
        if not re.match(r"CVE-\d{4}-\d{4,7}", cve_id):
            self.log_message(f"[red]Invalid CVE format: {cve_id}[/red]")
            return
        
        self.log_message(f"[cyan]Searching for {cve_id}...[/cyan]")
        self.push_screen(CVEDetailScreen(cve_id))
    
    def on_input_submitted(self, event: Input.Submitted) -> None:
        """Handle Enter key in CVE input."""
        if event.input.id == "cve-input":
            self.search_cve()


if __name__ == "__main__":
    app = ANSSIMonitorApp()
    app.run()
